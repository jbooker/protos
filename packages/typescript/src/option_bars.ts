/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.24.3
 * source: option_bars.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export class OptionBar extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        symbol?: string;
        bar?: OptionBarData;
        bars?: OptionBarData[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("symbol" in data && data.symbol != undefined) {
                this.symbol = data.symbol;
            }
            if ("bar" in data && data.bar != undefined) {
                this.bar = data.bar;
            }
            if ("bars" in data && data.bars != undefined) {
                this.bars = data.bars;
            }
        }
    }
    get symbol() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set symbol(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get bar() {
        return pb_1.Message.getWrapperField(this, OptionBarData, 2) as OptionBarData;
    }
    set bar(value: OptionBarData) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_bar() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get bars() {
        return pb_1.Message.getRepeatedWrapperField(this, OptionBarData, 3) as OptionBarData[];
    }
    set bars(value: OptionBarData[]) {
        pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    static fromObject(data: {
        symbol?: string;
        bar?: ReturnType<typeof OptionBarData.prototype.toObject>;
        bars?: ReturnType<typeof OptionBarData.prototype.toObject>[];
    }): OptionBar {
        const message = new OptionBar({});
        if (data.symbol != null) {
            message.symbol = data.symbol;
        }
        if (data.bar != null) {
            message.bar = OptionBarData.fromObject(data.bar);
        }
        if (data.bars != null) {
            message.bars = data.bars.map(item => OptionBarData.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            symbol?: string;
            bar?: ReturnType<typeof OptionBarData.prototype.toObject>;
            bars?: ReturnType<typeof OptionBarData.prototype.toObject>[];
        } = {};
        if (this.symbol != null) {
            data.symbol = this.symbol;
        }
        if (this.bar != null) {
            data.bar = this.bar.toObject();
        }
        if (this.bars != null) {
            data.bars = this.bars.map((item: OptionBarData) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.symbol.length)
            writer.writeString(1, this.symbol);
        if (this.has_bar)
            writer.writeMessage(2, this.bar, () => this.bar.serialize(writer));
        if (this.bars.length)
            writer.writeRepeatedMessage(3, this.bars, (item: OptionBarData) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OptionBar {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OptionBar();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.symbol = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.bar, () => message.bar = OptionBarData.deserialize(reader));
                    break;
                case 3:
                    reader.readMessage(message.bars, () => pb_1.Message.addToRepeatedWrapperField(message, 3, OptionBarData.deserialize(reader), OptionBarData));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OptionBar {
        return OptionBar.deserialize(bytes);
    }
}
export class OptionBarData extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        symbol?: string;
        timestamp?: string;
        open?: number;
        high?: number;
        low?: number;
        close?: number;
        volume?: number;
        trade_count?: number;
        vwap?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("symbol" in data && data.symbol != undefined) {
                this.symbol = data.symbol;
            }
            if ("timestamp" in data && data.timestamp != undefined) {
                this.timestamp = data.timestamp;
            }
            if ("open" in data && data.open != undefined) {
                this.open = data.open;
            }
            if ("high" in data && data.high != undefined) {
                this.high = data.high;
            }
            if ("low" in data && data.low != undefined) {
                this.low = data.low;
            }
            if ("close" in data && data.close != undefined) {
                this.close = data.close;
            }
            if ("volume" in data && data.volume != undefined) {
                this.volume = data.volume;
            }
            if ("trade_count" in data && data.trade_count != undefined) {
                this.trade_count = data.trade_count;
            }
            if ("vwap" in data && data.vwap != undefined) {
                this.vwap = data.vwap;
            }
        }
    }
    get symbol() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set symbol(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get timestamp() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set timestamp(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get open() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set open(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get high() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set high(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get low() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set low(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    get close() {
        return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
    }
    set close(value: number) {
        pb_1.Message.setField(this, 6, value);
    }
    get volume() {
        return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
    }
    set volume(value: number) {
        pb_1.Message.setField(this, 7, value);
    }
    get trade_count() {
        return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
    }
    set trade_count(value: number) {
        pb_1.Message.setField(this, 8, value);
    }
    get vwap() {
        return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
    }
    set vwap(value: number) {
        pb_1.Message.setField(this, 9, value);
    }
    static fromObject(data: {
        symbol?: string;
        timestamp?: string;
        open?: number;
        high?: number;
        low?: number;
        close?: number;
        volume?: number;
        trade_count?: number;
        vwap?: number;
    }): OptionBarData {
        const message = new OptionBarData({});
        if (data.symbol != null) {
            message.symbol = data.symbol;
        }
        if (data.timestamp != null) {
            message.timestamp = data.timestamp;
        }
        if (data.open != null) {
            message.open = data.open;
        }
        if (data.high != null) {
            message.high = data.high;
        }
        if (data.low != null) {
            message.low = data.low;
        }
        if (data.close != null) {
            message.close = data.close;
        }
        if (data.volume != null) {
            message.volume = data.volume;
        }
        if (data.trade_count != null) {
            message.trade_count = data.trade_count;
        }
        if (data.vwap != null) {
            message.vwap = data.vwap;
        }
        return message;
    }
    toObject() {
        const data: {
            symbol?: string;
            timestamp?: string;
            open?: number;
            high?: number;
            low?: number;
            close?: number;
            volume?: number;
            trade_count?: number;
            vwap?: number;
        } = {};
        if (this.symbol != null) {
            data.symbol = this.symbol;
        }
        if (this.timestamp != null) {
            data.timestamp = this.timestamp;
        }
        if (this.open != null) {
            data.open = this.open;
        }
        if (this.high != null) {
            data.high = this.high;
        }
        if (this.low != null) {
            data.low = this.low;
        }
        if (this.close != null) {
            data.close = this.close;
        }
        if (this.volume != null) {
            data.volume = this.volume;
        }
        if (this.trade_count != null) {
            data.trade_count = this.trade_count;
        }
        if (this.vwap != null) {
            data.vwap = this.vwap;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.symbol.length)
            writer.writeString(1, this.symbol);
        if (this.timestamp.length)
            writer.writeString(2, this.timestamp);
        if (this.open != 0)
            writer.writeDouble(3, this.open);
        if (this.high != 0)
            writer.writeDouble(4, this.high);
        if (this.low != 0)
            writer.writeDouble(5, this.low);
        if (this.close != 0)
            writer.writeDouble(6, this.close);
        if (this.volume != 0)
            writer.writeDouble(7, this.volume);
        if (this.trade_count != 0)
            writer.writeDouble(8, this.trade_count);
        if (this.vwap != 0)
            writer.writeDouble(9, this.vwap);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OptionBarData {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OptionBarData();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.symbol = reader.readString();
                    break;
                case 2:
                    message.timestamp = reader.readString();
                    break;
                case 3:
                    message.open = reader.readDouble();
                    break;
                case 4:
                    message.high = reader.readDouble();
                    break;
                case 5:
                    message.low = reader.readDouble();
                    break;
                case 6:
                    message.close = reader.readDouble();
                    break;
                case 7:
                    message.volume = reader.readDouble();
                    break;
                case 8:
                    message.trade_count = reader.readDouble();
                    break;
                case 9:
                    message.vwap = reader.readDouble();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OptionBarData {
        return OptionBarData.deserialize(bytes);
    }
}
export class OptionBarsRequest extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        symbols?: string[];
        timeframe?: string;
        start?: string;
        end?: string;
        limit?: number;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("symbols" in data && data.symbols != undefined) {
                this.symbols = data.symbols;
            }
            if ("timeframe" in data && data.timeframe != undefined) {
                this.timeframe = data.timeframe;
            }
            if ("start" in data && data.start != undefined) {
                this.start = data.start;
            }
            if ("end" in data && data.end != undefined) {
                this.end = data.end;
            }
            if ("limit" in data && data.limit != undefined) {
                this.limit = data.limit;
            }
        }
    }
    get symbols() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set symbols(value: string[]) {
        pb_1.Message.setField(this, 1, value);
    }
    get timeframe() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set timeframe(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get start() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set start(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get end() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set end(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    get limit() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set limit(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    static fromObject(data: {
        symbols?: string[];
        timeframe?: string;
        start?: string;
        end?: string;
        limit?: number;
    }): OptionBarsRequest {
        const message = new OptionBarsRequest({});
        if (data.symbols != null) {
            message.symbols = data.symbols;
        }
        if (data.timeframe != null) {
            message.timeframe = data.timeframe;
        }
        if (data.start != null) {
            message.start = data.start;
        }
        if (data.end != null) {
            message.end = data.end;
        }
        if (data.limit != null) {
            message.limit = data.limit;
        }
        return message;
    }
    toObject() {
        const data: {
            symbols?: string[];
            timeframe?: string;
            start?: string;
            end?: string;
            limit?: number;
        } = {};
        if (this.symbols != null) {
            data.symbols = this.symbols;
        }
        if (this.timeframe != null) {
            data.timeframe = this.timeframe;
        }
        if (this.start != null) {
            data.start = this.start;
        }
        if (this.end != null) {
            data.end = this.end;
        }
        if (this.limit != null) {
            data.limit = this.limit;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.symbols.length)
            writer.writeRepeatedString(1, this.symbols);
        if (this.timeframe.length)
            writer.writeString(2, this.timeframe);
        if (this.start.length)
            writer.writeString(3, this.start);
        if (this.end.length)
            writer.writeString(4, this.end);
        if (this.limit != 0)
            writer.writeInt32(5, this.limit);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OptionBarsRequest {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OptionBarsRequest();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                    break;
                case 2:
                    message.timeframe = reader.readString();
                    break;
                case 3:
                    message.start = reader.readString();
                    break;
                case 4:
                    message.end = reader.readString();
                    break;
                case 5:
                    message.limit = reader.readInt32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OptionBarsRequest {
        return OptionBarsRequest.deserialize(bytes);
    }
}
export class OptionBarsResponse extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        bars?: Map<string, OptionBarList>;
        symbols?: string[];
        count?: number;
        timeframe?: string;
        start?: string;
        end?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("bars" in data && data.bars != undefined) {
                this.bars = data.bars;
            }
            if ("symbols" in data && data.symbols != undefined) {
                this.symbols = data.symbols;
            }
            if ("count" in data && data.count != undefined) {
                this.count = data.count;
            }
            if ("timeframe" in data && data.timeframe != undefined) {
                this.timeframe = data.timeframe;
            }
            if ("start" in data && data.start != undefined) {
                this.start = data.start;
            }
            if ("end" in data && data.end != undefined) {
                this.end = data.end;
            }
        }
        if (!this.bars)
            this.bars = new Map();
    }
    get bars() {
        return pb_1.Message.getField(this, 1) as any as Map<string, OptionBarList>;
    }
    set bars(value: Map<string, OptionBarList>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    get symbols() {
        return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
    }
    set symbols(value: string[]) {
        pb_1.Message.setField(this, 2, value);
    }
    get count() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set count(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get timeframe() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set timeframe(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    get start() {
        return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
    }
    set start(value: string) {
        pb_1.Message.setField(this, 5, value);
    }
    get end() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set end(value: string) {
        pb_1.Message.setField(this, 6, value);
    }
    static fromObject(data: {
        bars?: {
            [key: string]: ReturnType<typeof OptionBarList.prototype.toObject>;
        };
        symbols?: string[];
        count?: number;
        timeframe?: string;
        start?: string;
        end?: string;
    }): OptionBarsResponse {
        const message = new OptionBarsResponse({});
        if (typeof data.bars == "object") {
            message.bars = new Map(Object.entries(data.bars).map(([key, value]) => [key, OptionBarList.fromObject(value)]));
        }
        if (data.symbols != null) {
            message.symbols = data.symbols;
        }
        if (data.count != null) {
            message.count = data.count;
        }
        if (data.timeframe != null) {
            message.timeframe = data.timeframe;
        }
        if (data.start != null) {
            message.start = data.start;
        }
        if (data.end != null) {
            message.end = data.end;
        }
        return message;
    }
    toObject() {
        const data: {
            bars?: {
                [key: string]: ReturnType<typeof OptionBarList.prototype.toObject>;
            };
            symbols?: string[];
            count?: number;
            timeframe?: string;
            start?: string;
            end?: string;
        } = {};
        if (this.bars != null) {
            data.bars = (Object.fromEntries)((Array.from)(this.bars).map(([key, value]) => [key, value.toObject()]));
        }
        if (this.symbols != null) {
            data.symbols = this.symbols;
        }
        if (this.count != null) {
            data.count = this.count;
        }
        if (this.timeframe != null) {
            data.timeframe = this.timeframe;
        }
        if (this.start != null) {
            data.start = this.start;
        }
        if (this.end != null) {
            data.end = this.end;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.bars) {
            writer.writeMessage(1, this.bars, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        if (this.symbols.length)
            writer.writeRepeatedString(2, this.symbols);
        if (this.count != 0)
            writer.writeInt32(3, this.count);
        if (this.timeframe.length)
            writer.writeString(4, this.timeframe);
        if (this.start.length)
            writer.writeString(5, this.start);
        if (this.end.length)
            writer.writeString(6, this.end);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OptionBarsResponse {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OptionBarsResponse();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.bars as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = OptionBarList.deserialize(reader));
                        return value;
                    }));
                    break;
                case 2:
                    pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                    break;
                case 3:
                    message.count = reader.readInt32();
                    break;
                case 4:
                    message.timeframe = reader.readString();
                    break;
                case 5:
                    message.start = reader.readString();
                    break;
                case 6:
                    message.end = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OptionBarsResponse {
        return OptionBarsResponse.deserialize(bytes);
    }
}
export class OptionBarList extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        bars?: OptionBarData[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("bars" in data && data.bars != undefined) {
                this.bars = data.bars;
            }
        }
    }
    get bars() {
        return pb_1.Message.getRepeatedWrapperField(this, OptionBarData, 1) as OptionBarData[];
    }
    set bars(value: OptionBarData[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        bars?: ReturnType<typeof OptionBarData.prototype.toObject>[];
    }): OptionBarList {
        const message = new OptionBarList({});
        if (data.bars != null) {
            message.bars = data.bars.map(item => OptionBarData.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            bars?: ReturnType<typeof OptionBarData.prototype.toObject>[];
        } = {};
        if (this.bars != null) {
            data.bars = this.bars.map((item: OptionBarData) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.bars.length)
            writer.writeRepeatedMessage(1, this.bars, (item: OptionBarData) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OptionBarList {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OptionBarList();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.bars, () => pb_1.Message.addToRepeatedWrapperField(message, 1, OptionBarData.deserialize(reader), OptionBarData));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): OptionBarList {
        return OptionBarList.deserialize(bytes);
    }
}
